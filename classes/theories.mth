Draft: A language for formal mathematics
========================================

All characters are visible unicode characters.

Text outside named blocks is ordinary text.

Formal statements are in named blocks denoted by Keyword name ... end [name].

The language for formal statements is (a variant of) typed higher-order logic.

The logical symbols are:  and, or, not, âŸ¹, âŸ¸, âŸº, âˆ€, âˆƒ, Î», 

The type constructors are: Ã—, +, â†’    Type separators  : (for function type), âˆˆ (for other types)

Predefined constant types: ğŸ˜, ğŸ™, ğ”¹, â„•, â„¤, â„š, â„, â„‚

Mathematical symbols: =, â‰ , â‰¤, â‰°, â‰¥, â‰±, any unicode symbol

Inside a Category block all undefined symbols are (type) variables.

Category names are usually plural [optional abbreviations are singular].

All introduced constants are exposed as parameters.

If morphisms are not specified they are algebraic/relational homomorphisms.

priority: logical relation 

Category preorders Pre(A,âŠ‘)
  âŠ‘ : AÃ—A â†’ ğ”¹, infix
  reflexivity:  x âŠ‘ x
  transitivity: x âŠ‘ y and y âŠ‘ z âŸ¹ x âŠ‘ z
end

Category partial_orders Pos(A,â‰¤)  -- posets
  extends preorders(A,â‰¤)
  antisymmetry: x â‰¤ y and y â‰¤ x âŸ¹ x = y
end

Category unary_residuated_posets uRPos(A,â‰¤,â¬¦,â—¼)
  extends partial_orders(A,â‰¤)
  â¬¦ : A â†’ A, prefix
  â—¼ : A â†’ A, prefix
  residuation: â¬¦x â‰¤ y âŸº x â‰¤ â—¼y
end

Category residuated_posets RPos(A,â‰¤,â‹…,\,/)
  extends partial_orders(A,â‰¤)
  â‹… : AÃ—A â†’ A, infix multiplication
  \ : AÃ—A â†’ A, infix division
  / : AÃ—A â†’ A, infix division
  residuation_l: xâ‹…y â‰¤ z âŸº y â‰¤ x\z
  residuation_r: xâ‹…y â‰¤ z âŸº x â‰¤ z/y
end

Category semigroups Sgrp(A,â‹…)
  â‹… : AÃ—A â†’ A, infix 5
  associativity: (xâ‹…y)â‹…z = xâ‹…(yâ‹…z)
end

Category commutative_semigroups CSgrp(A,â‹…)
  extends semigroups(A,â‹…)
  commutativity: xâ‹…y = yâ‹…x
end

Category semilattices Slat(A,â‹…)
  extends commutative_semigroups(â‹…)
  idempotence: xâ‹…x = x
end

Category unital_semilattices uSlat(A,â‹…,e)
  extends semilattices(A,â‹…)
  e : A
  identity_r: xâ‹…e = x
end

Category join_semilattices jSlat(A,âˆ¨)
  extends semilattices(A,âˆ¨)
  â‰¤ : AÃ—A â†’ ğ”¹, infix
  x â‰¤ y âŸº x âˆ¨ y = x
end

Category lattices Lat(A,âˆ§,âˆ¨)
  extends semilattices(A,âˆ§), semilattices(A,âˆ¨)
  absorption_1: x âˆ§ (x âˆ¨ y) = x
  absorption_2: x âˆ¨ (x âˆ§ y) = x
end

Category residuated_lattices RLat(A,âˆ§,âˆ¨,â‹…,e,\,/)
  extends lattices(A,âˆ§,âˆ¨), monoids(A,â‹…,e)
  residuation_l: xâ‹…y â‰¤ z âŸº y â‰¤ x\z
  residuation_r: xâ‹…y â‰¤ z âŸº x â‰¤ z/y
end

Category unary_operator(A,âˆ¨,â¬¦)
  extends semilattices(A,âˆ¨)
  0 : A
  â¬¦ : A â†’ A
  normal:          â¬¦0 = 0
  join-preserving: â¬¦(x âˆ¨ y) = â¬¦x âˆ¨ â¬¦y
end

Functor ????

How to define categories of partial functions?

Partial functions have type  f: AÃ—A â†’ A+ğŸ™


Category partial_semigroups PSgrp(A,â‹…)
  â‹… : AÃ—A â†’ A+ğŸ™
  associativity: (xâ‹…y)â‹…z = xâ‹…(yâ‹…z)  -- Kleene equality
end

Category effect_algebra EffAlg(A,+,',0,1)
  extends generalized_effect_algebras
  + : AÃ—A â†’ A+ğŸ™
  ' : A â†’ A+ğŸ™
  0,1 âˆˆ A
  0' = 1
end

âˆƒz (x+z=y) <-> âˆƒz (z+x=y)